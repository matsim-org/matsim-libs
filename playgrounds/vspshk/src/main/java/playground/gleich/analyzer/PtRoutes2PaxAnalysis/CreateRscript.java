/* *********************************************************************** *
 * project: org.matsim.*
 *                                                                         *
 * *********************************************************************** *
 *                                                                         *
 * copyright       : (C) 2012 by the members listed in the COPYING,        *
 *                   LICENSE and WARRANTY file.                            *
 * email           : info at matsim dot org                                *
 *                                                                         *
 * *********************************************************************** *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *   See also COPYING, LICENSE and WARRANTY file                           *
 *                                                                         *
 * *********************************************************************** */
package playground.gleich.analyzer.PtRoutes2PaxAnalysis;

import java.io.BufferedWriter;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.Map;

import org.apache.log4j.Logger;
import org.matsim.api.core.v01.Id;
import org.matsim.api.core.v01.Scenario;
import org.matsim.core.config.ConfigUtils;
import org.matsim.core.scenario.ScenarioUtils;
import org.matsim.core.utils.io.IOUtils;
import org.matsim.core.utils.misc.Time;
import org.matsim.pt.transitSchedule.api.TransitLine;
import org.matsim.pt.transitSchedule.api.TransitRoute;
import org.matsim.pt.transitSchedule.api.TransitScheduleReader;

/**
 * @author droeder
 *
 */
public class CreateRscript {

	@SuppressWarnings("unused")
	private static final Logger log = Logger.getLogger(CreateRscript.class);

	private CreateRscript() {
	}
	
	public static void main(String[] args) {
		String dir = "E:\\VSP\\svn\\droeder\\southAfrica\\testReRoute\\testReRoute3Old\\";
		Scenario sc = ScenarioUtils.createScenario(ConfigUtils.createConfig());
		sc.getConfig().transit().setUseTransit(true);
		sc.getConfig().scenario().setUseVehicles(true);
		new TransitScheduleReader(sc).readFile(dir + "ITERS\\it.299\\testReRoute3Old.299.transitSchedule.xml.gz");
		createScript(sc.getTransitSchedule().getTransitLines(), dir + "PtRoutes2PaxAnalysis\\", 60*60.0, 24);
	}
	/**
	 * Creates R-scripts according to the output generated by PtRoutes2PaxAnalysis
	 * 
	 * @param schedule
	 * @param outDir
	 */
	public static void createScript(Map<Id<TransitLine>, TransitLine> lines, String outDir, double interval, int maxSlices){
		readScript(outDir, interval, maxSlices);
		heatmapScript(outDir, interval, maxSlices);
		
		StringBuffer b = new StringBuffer();
		
		for(TransitLine l: lines.values()){
			for(TransitRoute r: l.getRoutes().values()){
				createRouteScript(l.getId(), r.getId(), outDir);
				b.append(l.getId().toString() + "--" + r.getId().toString() + ".R\n");
			}
		}
		
		BufferedWriter w = IOUtils.getBufferedWriter(outDir + "plotAll.bat");
		try {
			w.write(
					b.toString()
				);
			w.flush();
			w.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * @param id
	 * @param id2
	 */
	private static void createRouteScript(Id lineId, Id routeId, String outDir) {
		BufferedWriter w = IOUtils.getBufferedWriter(outDir + lineId.toString() + "--" + routeId.toString() + ".R");
		try {
			w.write("rm(list = ls(all = TRUE))\n");
			w.write("library(gplots)\n");
			w.write("pdf(\"" + lineId.toString() + "--" + routeId.toString() + ".pdf\")\n\n");
			w.write(readAndPlotSingleFile(outDir, lineId.toString() + "--" + routeId.toString(), "boarding"));
			w.write(readAndPlotSingleFile(outDir, lineId.toString() + "--" + routeId.toString(), "alighting"));
			w.write(readAndPlotSingleFile(outDir, lineId.toString() + "--" + routeId.toString(), "totalPax"));
			w.write(readAndPlotSingleFile(outDir, lineId.toString() + "--" + routeId.toString(), "occupancy"));
			w.write(readAndPlotSingleFile(outDir, lineId.toString() + "--" + routeId.toString(), "capacity"));
			w.write("dev.off()");
			w.flush();
			w.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	private static String readAndPlotSingleFile(String outdir, String routeLine, String filetype){
		StringBuffer b = new StringBuffer();
		String infile = routeLine + "--" + filetype + ".csv";
		
		b.append("file<-\"" + infile + "\"\n");
		b.append("source(\"read.R\")\n");
		b.append("mainLabel <- \"" + filetype + "\"\n");
		b.append("source(\"heatmap.R\")\n\n");
		return b.toString();
	}


	private static void readScript(String outdir, double interval, int maxSlices){
		BufferedWriter w = IOUtils.getBufferedWriter(outdir + "read.R");
		try {
			w.write(
					"data <- read.table(file, sep=\";\", header=T, na.strings=\"--\", fileEncoding=\"UTF8\")\n" +
					// maxSlices + 1 to cater for measurements after the last slice (time > maxSlices*interval)
					"values <- array(0, dim=c(length(data$index)," + (maxSlices + 1) + "))\n");
			DecimalFormat rFormat = new DecimalFormat("00");
			for(int i = 0; i < maxSlices; i++){
				//R modifies the column names from "08:00-08:30" to "X08.00.08.30"
				int begin = (int) (i * interval);
				String beginString = rFormat.format(begin / (60 * 60)) + "." + rFormat.format((begin / 60) % 60);
				int end = (int) ((i + 1) * interval);
				String endString = rFormat.format(end / (60 * 60)) + "." + rFormat.format((end / 60) % 60);
				w.write("values[," + (i + 1) + "]  <- data$X" + beginString + "." + endString + "\n");
			}
			// measurements after the last slice
			int begin = (int) (maxSlices * interval);
			String beginString = rFormat.format(begin / (60 * 60)) + "." + rFormat.format((begin / 60) % 60);
			w.write("values[," + (maxSlices + 1) + "]  <- data$X." + beginString + "\n");

			w.flush();
			w.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	private static void heatmapScript(String outdir, double interval, int maxSlices){
		BufferedWriter w = IOUtils.getBufferedWriter(outdir + "heatmap.R");
		StringBuffer labCol = new StringBuffer();
		labCol.append("c(\n\t");
		for(int i = (int) interval; i < (maxSlices * (int) interval) + 1; i+= (int) interval){
			labCol.append("\"" + Time.writeTime(i -(int) interval, Time.TIMEFORMAT_HHMM) + "-" + Time.writeTime(i, Time.TIMEFORMAT_HHMM) + "\",\n\t");
		}
		labCol.append("\"> " + Time.writeTime(maxSlices * (int) interval, Time.TIMEFORMAT_HHMM) + "\")");
		try {
			w.write(
					"library(RColorBrewer)  \n" +
					"heatmap.2(values,\n\t"+
							"colsep=c(1:" + (maxSlices + 1) + "),\n\t"+
							"rowsep=c(1:length(data$index)),\n\t"+
							"sepcolor=\"white\",\n\t"+
							"tracecol=\"white\", \n\t" +
							"sepwidth=c(1/length(data$index),1/" + (maxSlices + 1) + "),\n\t"+
							"dendrogram=\"none\",\n\t"+
							"Colv=\"none\",\n\t"+
							"Rowv=\"none\",\n\t"+
							"trace=\"none\",\n\t"+
//							"xlab=\"time\",\n\t"+
							"main=mainLabel,\n\t"+
							"labRow=data$name, \n\t" +
							"# the position of the tables elements, 1 = heatmap, 2 = ??, 3 = heading, 4 = legend \n\t" +
							"# the graphic area is divided into a matrix with 4 lines and 4 columns, c(...) are the lines. \n\t" +
//							"lmat=rbind(c(2,0,0,4), c(0,3,3,4), c(0,1,1,0), c(0,1,1,0)), \n\t" + 
//							"lhei=c(0.5,0.5,1,1), \n\t" +
//							"lwid=c(0.1,1,1,1), \n\t" +
							"lmat=rbind(c(2,0,3,0,0), c(0,1,1,1,0), c(0,1,1,1,0), c(0,1,1,1,0), c(0,1,1,1,4), c(0,0,0,4,4)), \n\t" + 
							"lhei=c(0.5,1,1,1,0.4,1), \n\t" +
							"lwid=c(0.2,1,1,0.3,0.7),\n\t"+
							"col=colorRampPalette(c(\"#e6e6e6\", \"#010101\"))(9), \n\t" +
//							"col=brewer.pal(9,\"Greys\"), \n\t" +
							"labCol=" + labCol.toString() + "\n" + 
					")"
				);
			w.flush();
			w.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

