/* *********************************************************************** *
 * project: org.matsim.*
 *                                                                         *
 * *********************************************************************** *
 *                                                                         *
 * copyright       : (C) 2012 by the members listed in the COPYING,        *
 *                   LICENSE and WARRANTY file.                            *
 * email           : info at matsim dot org                                *
 *                                                                         *
 * *********************************************************************** *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *   See also COPYING, LICENSE and WARRANTY file                           *
 *                                                                         *
 * *********************************************************************** */
package playground.vsp.analysis.modules.ptRoutes2paxAnalysis;

import java.io.BufferedWriter;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.Map;

import org.apache.log4j.Logger;
import org.matsim.api.core.v01.Id;
import org.matsim.api.core.v01.Scenario;
import org.matsim.core.config.ConfigUtils;
import org.matsim.core.scenario.ScenarioUtils;
import org.matsim.core.utils.io.IOUtils;
import org.matsim.core.utils.misc.Time;
import org.matsim.pt.transitSchedule.api.TransitLine;
import org.matsim.pt.transitSchedule.api.TransitRoute;
import org.matsim.pt.transitSchedule.api.TransitScheduleReader;

import playground.vsp.analysis.modules.ptLines2PaxAnalysis.TransitLines2PaxCounts;

/**
 * @author droeder
 *
 */
public class CreateRscript {

	@SuppressWarnings("unused")
	private static final Logger log = Logger.getLogger(CreateRscript.class);

	private CreateRscript() {
	}
	
	public static void main(String[] args) {
		String dir = "E:\\VSP\\svn\\droeder\\southAfrica\\testReRoute\\testReRoute3Old\\";
		Scenario sc = ScenarioUtils.createScenario(ConfigUtils.createConfig());
		sc.getConfig().transit().setUseTransit(true);
		new TransitScheduleReader(sc).readFile(dir + "ITERS\\it.299\\testReRoute3Old.299.transitSchedule.xml.gz");
		createScript(sc.getTransitSchedule().getTransitLines(), dir + "PtRoutes2PaxAnalysis\\", 60*60.0, 24);
	}
	/**
	 * Creates R-scripts according to the output generated by PtRoutes2PaxAnalysis
	 * 
	 * @param schedule
	 * @param outDir
	 */
	public static void createScript(Map<Id<TransitLine>, TransitLine> lines, String outDir, double interval, int maxSlices){
		readScript(outDir, interval, maxSlices);
		heatmapScript(outDir, interval, maxSlices);
		
		/* b for the plotAll.bat, b2 added by gleich for the alternative plotAll.R */
		StringBuffer b = new StringBuffer();
		StringBuffer b2 = new StringBuffer();
		
		for(TransitLine l: lines.values()){
			for(TransitRoute r: l.getRoutes().values()){
				createRouteScript(l.getId(), r.getId(), outDir);
				b.append(l.getId().toString() + "--" + r.getId().toString() + ".R\n");
				b2.append("source(\"" +	l.getId().toString() + "--" + r.getId().toString() +".R\")\n");
			}
		}
		
		BufferedWriter w = IOUtils.getBufferedWriter(outDir + "plotAll.bat");
		try {
			w.write(
					b.toString()
				);
			w.flush();
			w.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		/* w2 added by gleich for the alternative plotAll.R */
		BufferedWriter w2 = IOUtils.getBufferedWriter(outDir + "plotAll.R");
		try {
			w2.write(
					b2.toString()
				);
			w2.flush();
			w2.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	// created for use with PtLines2PaxAnalysis, fuerbas
	public static void createScriptFromTransitLines2PaxCounts (Map<Id,TransitLines2PaxCounts> tl2c, String outDir, double interval, int maxSlices) {
		readScript(outDir, interval, maxSlices);
		heatmapScript(outDir, interval, maxSlices);
		/* b for the plotAll.bat, b2 added by gleich for the alternative plotAll.R */
		StringBuffer b = new StringBuffer();
		StringBuffer b2 = new StringBuffer();
		
		for(TransitLines2PaxCounts l: tl2c.values()){
			for(TransitRoute r: l.getRouteList()){
				createRouteScript(l.getId(), r.getId(), outDir);
				b.append(l.getId().toString() + "--" + r.getId().toString() + ".R\n");
				b2.append("source(\"" +	l.getId().toString() + "--" + r.getId().toString() +".R\")\n");
			}
		}

		BufferedWriter w = IOUtils.getBufferedWriter(outDir + "plotAll.bat");
		try {
			w.write(
					b.toString()
				);
			w.flush();
			w.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		/* w2 added by gleich for the alternative plotAll.R */
		BufferedWriter w2 = IOUtils.getBufferedWriter(outDir + "plotAll.R");
		try {
			w2.write(
					b2.toString()
				);
			w2.flush();
			w2.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * @param id
	 * @param id2
	 */
	private static void createRouteScript(Id lineId, Id routeId, String outDir) {
		BufferedWriter w = IOUtils.getBufferedWriter(outDir + lineId.toString() + "--" + routeId.toString() + ".R");
		try {
			w.write("rm(list = ls(all = TRUE))\n");
			w.write("library(gplots)\n");
			w.write("pdf(\"" + lineId.toString() + "--" + routeId.toString() + ".pdf\")\n\n");
			w.write(readAndPlotSingleFile(outDir, lineId.toString() + "--" + routeId.toString(), "boarding"));
			w.write(readAndPlotSingleFile(outDir, lineId.toString() + "--" + routeId.toString(), "alighting"));
			w.write(readAndPlotSingleFile(outDir, lineId.toString() + "--" + routeId.toString(), "totalPax"));
			w.write(readAndPlotSingleFile(outDir, lineId.toString() + "--" + routeId.toString(), "occupancy"));
			w.write(readAndPlotSingleFile(outDir, lineId.toString() + "--" + routeId.toString(), "capacity"));
			w.write("dev.off()");
			w.flush();
			w.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	private static String readAndPlotSingleFile(String outdir, String routeLine, String filetype){
		StringBuffer b = new StringBuffer();
		String infile = routeLine + "--" + filetype + ".csv";
		
		b.append("file<-\"" + infile + "\"\n");
		b.append("source(\"read.R\")\n");
		b.append("mainLabel <- \"" + filetype + "\"\n");
		b.append("source(\"heatmap.R\")\n\n");
		return b.toString();
	}


	private static void readScript(String outdir, double interval, int maxSlices){
		BufferedWriter w = IOUtils.getBufferedWriter(outdir + "read.R");
		try {
			w.write(
					"data <- read.table(file, sep=\";\", header=T, na.strings=\"--\", fileEncoding=\"UTF8\")\n" +
					// maxSlices + 1 to cater for measurements after the last slice (time > maxSlices*interval)
					"values <- array(0, dim=c(length(data$index)," + (maxSlices + 1) + "))\n");
			DecimalFormat rFormat = new DecimalFormat("00");
			for(int i = 0; i < maxSlices; i++){
				int begin = (int) (i * interval);
				String beginString = "H" + rFormat.format(begin / (60 * 60)) + "M" + rFormat.format((begin / 60) % 60);
				int end = (int) ((i + 1) * interval);
				String endString = "H" + rFormat.format(end / (60 * 60)) + "M" + rFormat.format((end / 60) % 60);
				w.write("values[," + (i + 1) + "]  <- data$" + beginString + "_to_" + endString + "\n");
			}
			// measurements after the last slice
			int begin = (int) (maxSlices * interval);
			String beginString = "H" + rFormat.format(begin / (60 * 60)) + "M" + rFormat.format((begin / 60) % 60);
			w.write("values[," + (maxSlices + 1) + "]  <- data$" + beginString + "\n");

			w.flush();
			w.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	private static void heatmapScript(String outdir, double interval, int maxSlices){
		BufferedWriter w = IOUtils.getBufferedWriter(outdir + "heatmap.R");
		StringBuffer labCol = new StringBuffer();
		labCol.append("c(\n\t");
		for(int i = (int) interval; i < (maxSlices * (int) interval) + 1; i+= (int) interval){
			labCol.append("\"" + Time.writeTime(i -(int) interval, Time.TIMEFORMAT_HHMM) + "-" + Time.writeTime(i, Time.TIMEFORMAT_HHMM) + "\",\n\t\t");
		}
		labCol.append("\"> " + Time.writeTime(maxSlices * (int) interval, Time.TIMEFORMAT_HHMM) + "\")");
		try {
			w.write(
					"library(RColorBrewer)  \n" +
					"# Check for empty input data, possibly due to no passengers\n" +
					"testData <- values[!is.na(values)]\n" +
					"if(length(testData) > 0) {\n" +
						"heatmap.2(values,\n\t\t"+
							"colsep=c(1:" + (maxSlices + 1) + "),\n\t\t"+
							"rowsep=c(1:length(data$index)),\n\t\t"+
							"sepcolor=\"white\",\n\t\t"+
							"tracecol=\"white\", \n\t\t" +
							"sepwidth=c(1/length(data$index),1/" + (maxSlices + 1) + "),\n\t\t"+
							"dendrogram=\"none\",\n\t\t"+
							"Colv=\"none\",\n\t\t"+
							"Rowv=\"none\",\n\t\t"+
							"trace=\"none\",\n\t\t"+
//							"xlab=\"time\",\n\t\t"+
							"main=mainLabel,\n\t\t"+
							"labRow=data$name, \n\t\t" +
							"# the position of the tables elements, 1 = heatmap, 2 = ??, 3 = heading, 4 = legend \n\t\t" +
							"# the graphic area is divided into a matrix with 4 lines and 4 columns, c(...) are the lines. \n\t\t" +
//							"lmat=rbind(c(2,0,0,4), c(0,3,3,4), c(0,1,1,0), c(0,1,1,0)), \n\t\t" + 
//							"lhei=c(0.5,0.5,1,1), \n\t\t" +
//							"lwid=c(0.1,1,1,1), \n\t\t" +
							"lmat=rbind(c(2,0,3,0,0), c(0,1,1,1,0), c(0,1,1,1,0), c(0,1,1,1,0), c(0,1,1,1,4), c(0,0,0,4,4)), \n\t\t" + 
							"lhei=c(0.5,1,1,1,0.4,1), \n\t\t" +
							"lwid=c(0.2,1,1,0.3,0.7),\n\t\t"+
							"col=colorRampPalette(c(\"#e6e6e6\", \"#010101\"))(9), \n\t\t" +
//							"col=brewer.pal(9,\"Greys\"), \n\t\t" +
							"labCol=" + labCol.toString() + "\n" + 
						")" +
					"} else {\n\t" +
						// dummy plot to allow the text command
						"plot(0,0)\n\t" +
						"text(0, 0.1, paste(\"No valid data (possibly no passengers) for \\\"\", mainLabel, \"\\\"\"))\n" + 
					"}"
				);
			w.flush();
			w.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

